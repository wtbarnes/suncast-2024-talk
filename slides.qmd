---
title: "synthesizAR: A Python framework for forward-modeling optically-thin emission from field-aligned hydrodynamic models" 
subtitle: SUNCAST Workshop / NJIT / 28 February 2024
authors:
- Will Barnes
institute:
- AU/NASA GSFC
format:
  revealjs:
    margin: 0
    width: 100%
    height: 100%
    code-block-height: 1000px
    theme: [default,theme/sunpy-theme.scss]
    logo: static/sunpy_logo_portrait_powered.png
    css: logo.css
    footer: "[wtbarnes.github.io/suncast-2024-talk](https://wtbarnes.github.io/suncast-2024-talk)"
title-slide-attributes: 
  data-background-image: static/synthesizar_logo_vertical.png
  data-background-position: 5% 25%
  data-background-opacity: 45%
  data-background-size: 35%
bibliography: references.bib
csl: apj.csl
---
```{python}
#| echo: false
#| eval: true
import astropy.time
import astropy.units as u
import matplotlib.pyplot as plt
import numpy as np
import sunpy.map

from astropy.coordinates import SkyCoord
from astropy.visualization import ImageNormalize, quantity_support
```

## Problem

- Modeling optically-thin emission requires computing the following line-of-sight integral:
$$
p = \int\mathrm{d}h\,K(n,T)n^2,
$$
- where:
  - $K$ is the response function (e.g. instrument response, contribution function of line)
  - $n\equiv n(h),T\equiv T(h)$ are temperature and density along the LOS
- This requires knowing four things:
  1. What structures are emitting--geometry
  2. $T,n$ of emitting structures as a function of space and time--loop model
  3. How the plasma is emitting as a function of $n,T$--emission model
  4. How is the emission being observed--instrument

## The `synthesizAR` Package

- `synthesizAR` = `synthesi`s of `A`ctive `R`egion emission (pronounced like "synthesizer")
- Largely a product of my PhD--development started in 2016, sporadic since 2019, *many* growing pains
- Pure Python, leverages scientific Python and "PyAstro" software stack
- Modular design--geometry, field-aligned model, instrument, LOS are all configurable
- Parallelized using `dask`--emission computation from each loop is "embarassingly" parallel
- Emission model can account for time-dependent effects (e.g. non-equilibrium ionization)
- Limitations:
  - All emission is assumed to be **optically-thin**
  - All emission is assumed to be **thermal** (i.e. no transport effects)
  - All emission confined to **discrete field lines** (i.e. not volume filling)

::: {.aside}
More details in @barnes_understanding_2019
:::

## Workflow {background-image="figures/synthesizar-flowchart.png" background-size="85%" background-position="center"}

## Development

:::: {.columns}

::: {.column width="5%"}
:::

::: {.column width="45%"}
![](figures/synthesizar-github.png)
:::

::: {.column width="45%"}
![](figures/synthesizar-docs.png)
:::

::: {.column width="5%"}
:::

::::

::: footer
[github.com/wtbarnes/synthesizAR](https://github.com/wtbarnes/synthesizar)
:::

## Toy Loop Model

```{python}
#| echo: true
#| output-location: fragment
import synthesizAR
from synthesizAR.models import semi_circular_bundle

obstime = astropy.time.Time.now()
pos = SkyCoord(lon=0*u.deg, lat=0*u.deg, radius=1*u.AU, obstime=obstime, frame='heliographic_stonyhurst')
bundle_coords = semi_circular_bundle(50 * u.Mm, 1*u.Mm, 500, observer=pos)
print(bundle_coords[0][:2])
```

```{python}
#| echo: true
#| fig-align: center
#| output-location: fragment
strands = [synthesizAR.Loop(f'strand{i}', c) for i, c in enumerate(bundle_coords)]
bundle = synthesizAR.Skeleton(strands)
bundle.peek(observer=pos)
```

## Toy Loop Model

```{python}
#| echo: true
#| output-location: fragment
from synthesizAR.instruments import InstrumentSDOAIA
from synthesizAR.interfaces import RTVInterface

rtv = RTVInterface(heating_rate=1e-3*u.Unit('erg cm-3 s-1'))
bundle.load_loop_simulations(rtv)
print(bundle.loops[0].electron_temperature[0,:5])
print(bundle.loops[0].density[0,:5])
```

```{python}
#| echo: true
#| fig-align: center
#| output-location: fragment
aia = InstrumentSDOAIA([0, 1]*u.s, pos, pad_fov=(10, 10)*u.arcsec)
maps = aia.observe(bundle, channels=aia.channels[2:3])
maps['171'][0].peek()
```

## Toy Loop Model: Summary of Steps

1. What structures are emitting--`synthesizAR.Skeleton`, `synthesizAR.Loop`
2. $T,n$ of these structures as a function of $s,t$--`synthesizAR.interfaces.RTVInterface`
3. How plasma emits as a function of $T,n$--`synthesizAR.atomic.EmissionModel` (optional)
4. How is the emission being observed--`synthesizar.instruments.InstrumentSDOAIA`

```{mermaid}
flowchart LR
  coords["SkyCoord
		      SkyCoord
          ...
		      SkyCoord"]
  loops("synthesizAR.Loop
         synthesizAR.Loop
         ...
         synthesizAR.Loop"):::synthesizar
  skeleton("synthesizAR.Skeleton"):::synthesizar
  modelparams["model parameters"]
  model("synthesizAR.interfaces.RTVInterface"):::synthesizar
  observer["SkyCoord"]
  instrument("synthesizAR.instruments.InstrumentSDOAIA"):::synthesizar
  ions["fiasco.Ion
        fiasco.Ion
        ...
        fiasco.Ion"]
  emmodel("synthesizAR.atomic.EmissionModel"):::synthesizar
  smap(["sunpy.map.Map"])
  coords --> loops
  loops --> skeleton
  model --> skeleton
  modelparams --> model
  skeleton --> instrument
  observer --> instrument
  emmodel -.-> instrument
  ions --> emmodel
  instrument --> smap
  classDef synthesizar fill:#FE7900
```

## Toy Loop Model: Different Observer

```{python}
#| echo: true
#| fig-align: center
#| output-location: fragment
#| code-line-numbers: "|1"
side_on_view = SkyCoord(lon=0*u.deg, lat=-90*u.deg, radius=1*u.AU, frame=pos.frame)
aia = InstrumentSDOAIA([0, 1]*u.s, side_on_view, pad_fov=(10, 10)*u.arcsec)
maps = aia.observe(bundle, channels=aia.channels[2:3])
maps['171'][0].peek()
```

## Toy Loop Model: Using a Different Loop Model

```{python}
#| echo: true
#| fig-align: center
#| output-location: fragment
#| code-line-numbers: "|3,4"
from synthesizAR.interfaces import MartensInterface

martens = MartensInterface(1e-3*u.Unit('erg cm-3 s-1'))
bundle.load_loop_simulations(martens)
maps = aia.observe(bundle, channels=aia.channels[2:3])
maps['171'][0].peek()
```

## Aside: The `fiasco` Python interface to CHIANTI

- Object oriented approach, HDF5 database, `astropy.units` everywhere
- Currently only compatible with **v8** of the database

```{python}
#| echo: true
#| output-location: column-fragment
import fiasco
temperature = np.logspace(5, 7, 100) * u.K
fe_15 = fiasco.Ion('Fe 15', temperature)
print(fe_15)
```
```{python}
#| echo: true
#| output-location: column-fragment
print(fe_15[0])
```
```{python}
#| echo: true
#| output-location: column-fragment
print(fe_15.ionization_rate[50:55])
```

```{python}
#| echo: true
#| output-location: column-fragment
iron = fiasco.Element('iron', temperature)
print(type(iron[14]))
print(iron[14].ion_name)
```

::: footer
[github.com/wtbarnes/fiasco](https://github.com/wtbarnes/fiasco), [fiasco.readthedocs.io](https://fiasco.readthedocs.io)
:::

## Toy Loop Model: Advanced Emission Modeling

- By default, `InstrumentSDOAIA` computes emission using temperature response functions
- Insufficient for: varying abundances, density dependence, time-dependent ionization
- Alternative: compute emissivity of each loop *per ion* and then integrate over $R(\lambda)$
- `EmissionModel`: select which ions you want to include, temperature range, density range

```{python}
#| eval: false
#| echo: true
from synthesizAR.atomic import EmissionModel

ni_14 = fiasco.Ion('Ni XIV', temperature)
fe_9 = fiasco.Ion('Fe IX', temperature)

density = np.logspace(8,12,20) * u.cm**(-3)
em_model = EmissionModel(density, fe_9, ni_14)

em_model.calculate_emissivity_table('emiss_table.zarr')

maps = aia.observe(bundle, channels=aia.channels[2:3], emission_model=em_model)
```

## A Multi-instrument Example

```{python}
#| include: false
#| output: false
import sunpy
sunpy.log.setLevel('ERROR')
m_aia, m_eui, m_stereo = sunpy.map.Map('data/cutouts/*.fits')
```

```{python}
#| fig-align: center
fig = plt.figure(figsize=(16,4), layout='constrained')
for i,m in enumerate([m_aia, m_eui, m_stereo]):
    ax = fig.add_subplot(1,4,i+1,projection=m)
    norm = ImageNormalize() if m.instrument == 'EUI' else m.plot_settings['norm']
    m.plot(axes=ax,clip_interval=(1,99)*u.percent,norm=norm,title=f'{m.observatory} {m.nickname} {m.wavelength.value:.0f} Å')
    lon, lat = ax.coords
    lon.grid(alpha=0)
    lat.grid(alpha=0)
    lon.set_axislabel(' ')
    lat.set_axislabel(' ')
    lon.set_ticklabel_visible(False)
    lat.set_ticklabel_visible(False)
    lon.set_ticks_visible(False)
    lat.set_ticks_visible(False)
    hgs_lon, hgs_lat = m.draw_grid(axes=ax, grid_spacing=10*u.deg)
    hgs_lon.set_axislabel(' ')
    hgs_lat.set_axislabel(' ')
    hgs_lon.set_ticks_visible(False)
    hgs_lat.set_ticks_visible(False)
    hgs_lon.set_ticklabel_visible(False)
    hgs_lat.set_ticklabel_visible(False)

ax = fig.add_subplot(1,4,4,projection='polar')
ax.plot(0, 0, marker='o', markersize=20, color='yellow')
for m in [m_aia, m_eui, m_stereo]:
    sat = m.observatory
    coord = m.observer_coordinate
    ax.plot(coord.lon.to('rad'), coord.radius.to(u.AU), 'o', label=sat)
ax.set_theta_zero_location("S")
ax.set_rlabel_position(225)
ax.set_rlim(0, 1.075)
ax.legend(frameon=False);
```

- Active region observed by SDO/AIA, *Solar Orbiter* EUI, and STEREO EUVI on 2022-03-29 22:50
- AR observed near disk center--use corresponding HMI synoptic map + `pfsspy`
- Choose only *closed* loops in range $20<L<100$ Mm
- Serialize all information about magnetic "skeleton" to `asdf`

## A Multi-instrument Example

```{python}
#|echo: true
#| fig-align: center
skeleton = synthesizAR.Skeleton.from_asdf('data/skeleton.asdf')

skeleton.peek(
  observer=m_eui.observer_coordinate,
  check_visible=True,
  plot_kwargs={'alpha': 0.25},
  axes_limits=(u.Quantity([m_eui.bottom_left_coord.Tx, m_eui.top_right_coord.Tx]),
               u.Quantity([m_eui.bottom_left_coord.Ty, m_eui.top_right_coord.Ty]))
)
```

## A Multi-instrument Example

```{python}
#|echo: true
from synthesizAR.models.heating import b_over_l_scaling

class MartensCustom(MartensInterface):
    def get_heating_constant(self, loop):
        return b_over_l_scaling(loop, alpha=1, beta=1, H_0=.3e-3*u.Unit('erg cm-3 s-1'))

martens_model = MartensCustom(None, 0.1*u.MK)
skeleton.load_loop_simulations(martens_model)
```

```{python}
#|fig-align: center
fig = plt.figure(figsize=(15,7))
ax1 = fig.add_subplot(121)
ax2 = fig.add_subplot(122)
with quantity_support():
    for l in skeleton.loops:
        ax1.plot(l.field_aligned_coordinate_center_norm, l.electron_temperature.to('MK')[0], alpha=0.1, color='k')
        ax2.plot(l.field_aligned_coordinate_center_norm, l.density[0], alpha=0.1, color='k')
ax2.set_yscale('log')
ax1.set_xlabel(r'$s/L$')
ax2.set_xlabel(r'$s/L$');
```

## A Multi-instrument Example

```{python}
#|echo: true
class InstrumentSolarOrbiterEUIFSI(InstrumentSDOAIA):
    name = 'SolO_EUI'
        
    @property
    def observatory(self):
        return 'Solar Orbiter'
    
    @property
    def detector(self):
        return 'FSI'
    
    @property
    def telescope(self):
        return 'SOLO/EUI/FSI'

    @property
    def resolution(self):
        return u.Quantity([m_eui.scale.axis1, m_eui.scale.axis2])
    
    def get_instrument_name(self, *args):
        return 'EUI'
```

```{python}
class InstrumentSTEREOEUVI(InstrumentSDOAIA):
    name = 'STEREO_EUVI'
        
    @property
    def observatory(self):
        return 'STEREO A'
    
    @property
    def telescope(self):
        return 'STEREO'
    
    @property
    def detector(self):
        return 'EUVI'

    @property
    def resolution(self):
        return u.Quantity([m_stereo.scale.axis1, m_stereo.scale.axis2])
    
    def get_instrument_name(self, *args):
        return 'SECCHI'


def get_fov_from_submap(smap):
    fov_blc = smap.bottom_left_coord
    fov_trc = smap.top_right_coord
    return u.Quantity([fov_trc.Tx-fov_blc.Tx, fov_trc.Ty-fov_blc.Ty])
```

- New instruments defined through classes, typically by subclassing `InstrumentBase`
- Can be as simple as defining new names or complex as defining new ways to compute emissivity
- `InstrumentBase` defines the expected interface for a new instrument class

## A Multi-instrument Example

```{python}
#|echo: true
eui = InstrumentSolarOrbiterEUIFSI([0,1]*u.s,
                                   m_eui.observer_coordinate,
                                   fov_center=m_eui.center,
                                   fov_width=get_fov_from_submap(m_eui))
m_eui_model = eui.observe(skeleton, channels=eui.channels[2:3])['171'][0]
```

```{python}
m_eui_model.plot_settings['cmap'] = 'solar orbiterfsi174'

aia = InstrumentSDOAIA([0,1]*u.s,
                       m_aia.observer_coordinate,
                       fov_center=m_aia.center,
                       fov_width=get_fov_from_submap(m_aia))
m_aia_model = aia.observe(skeleton, channels=aia.channels[2:3], )['171'][0]
euvi = InstrumentSTEREOEUVI([0,1]*u.s,
                            m_stereo.observer_coordinate,
                            fov_center=m_stereo.center,
                            fov_width=get_fov_from_submap(m_stereo))
m_euvi_model = euvi.observe(skeleton, channels=eui.channels[2:3], )['171'][0]
```

```{python}
#|fig-align: center
fig = plt.figure(figsize=(21,7))
for i,m in enumerate([m_aia_model, m_eui_model, m_euvi_model]):
    ax = fig.add_subplot(1,3,i+1,projection=m)
    m.plot(axes=ax, clip_interval=(1,95)*u.percent,title=f'{m.observatory} {m.nickname} {m.wavelength.value:.0f} Å')
    lon, lat = ax.coords
    lon.grid(alpha=0)
    lat.grid(alpha=0)
    lon.set_axislabel(' ')
    lat.set_axislabel(' ')
    lon.set_ticklabel_visible(False)
    lat.set_ticklabel_visible(False)
    lon.set_ticks_visible(False)
    lat.set_ticks_visible(False)
    hgs_lon, hgs_lat = m.draw_grid(axes=ax, grid_spacing=10*u.deg)
    hgs_lon.set_axislabel(' ')
    hgs_lat.set_axislabel(' ')
    hgs_lon.set_ticks_visible(False)
    hgs_lat.set_ticks_visible(False)
    hgs_lon.set_ticklabel_visible(False)
    hgs_lat.set_ticklabel_visible(False)
```

## Application: Active Region Heating {background-video="movies/noaa1158_low_frequency.mp4" background-size="contain" background-video-loop="true"}

::: {.aside}
See @barnes_understanding_2019,@barnes_understanding_2021
:::

## Application: EUV Flare Emission {background-video="http://solar.physics.montana.edu/www/reu/2022/bparker/files/aia_211_dist.mp4" background-size="contain" background-video-loop="true"}

::: {.aside}
Courtesy Brock Parker and Chunming Zhu (MSU)
:::

## Application: Full-disk Stellar Modeling {background-iframe="https://drive.google.com/file/d/1Cjv6iCoDv6__iNRz2B_7jkGGPTS43KGu/preview"}

::: {.aside}
Courtesy Alison Farrish (NASA GSFC), @farrish_simulation_2018
:::

## Summary

:::: {.columns}

::: {.column width="5%"}
:::

::: {.column width="25%"}
![](static/synthesizar_logo_vertical.png)
:::

::: {.column width="65%"}
- `synthesizAR`--pure Python package for modeling time-dependent emission from field-aligned models
- Openly developed on GitHub, documentation on Read the Docs, testing on GH Actions
- Takes full advantage of the scientific Python stack + `astropy` + `sunpy`
- Prioritizes modularity and flexibility--geometry, loop models, instrument
- `sunpy.coordinates` + modularity enable multi-instrument modeling studies
- Future: stability, performance, loops with finite width, non-thermal emission
:::

::: {.column width="5%"}
:::

::::

---

::: {#refs}
:::
